react:

vid-1:
    frontend library for rich UI
    component based architecture
    react is declarative
    takes care of DOM updates
    react-native-> mbile app dev

also checkout on es6 playlist by codeevolution

vid-2:
    hello world
    install node.
    create-react-app cli tool=> to create and run a simple react app
    npx create-react-app nameofproject
    cd projectname ie cd hello-world
    npm start

alternate method to create react app:
    npx --> it is a npm package runner 
    npmx create-react-app projectname
                or
    by npm:
        npm install create-react-app -g
        create-react-app projectname

vid-3:
    file/folder structure
    package.json has dependencies and scripts for the applications
    nodemodule dir has all the dependencies code files
    public dir has 3 files, manifest.json is for progressive webapp,favicon is like logo,index.html is main html file which has a div tag with id root, on runtime react takes this div as wrapper and populates its components in it
    src dir is the source.  index.js -> here we specify the root component which is App and followed by DOM element controlled by react inside reactDOM.render(<App/>,document.getElementbyid('root'))
    app.js is now here the file with render() that makes what to be displayed in the root div element on this stage
    app.css ->corresponding css for app component
    app.test.js -> unit testfile for app component
    index.css-> css file for index.html 
    serviceworker -> it is for PWA react applications

vid-4:
    component - part of UI
    a component could be defined using a .js or .jsx file
    component type : functional/stateless component , class component
    SFC: normal js/jsx functions that returns either  ahtml/jsx format ui  .. doesn't have state 
    class component: normal ES6 class with state,render() etc..
    course instructor's app.js -> class component
    for me -> functional component here

vid-5:
    just js function that might get props as args and might returns html/jsx
    so now under src create component dir and under it create a file named greet.js which would be functional component now
    in app.js-> clear out everything under render()/return outerdiv
    make defn in greet.js and export it and then move to app.js and import it and under render()/div put the component name ie exported name Greet here
    making use of default export allows us to make import with any name of desire we want
    note: Component name must always start with capital letter -- rule
    name export is also a type of export used. 
    ie when  export  const Greet = () => return <h1>Hello </h1> we must try it to import on other file with same name Greet in our case now
    during such name export and import.. we must import it like import {Greet} from 'path'

vid-6:
    class component 
    ES6 classes it can also recieve props as args and also capable to maintain private internal state
    so create welcome.js under component which involves importing react and component class from react package
    do the export and import respectively
    sfc vs class component: 
            sfc-> simple functions, absence of 'this' keyword and scope issue, soln without state think approach,called dumb/presentational component
            class-> has state,has lifecycle hooks, comple ui logic implementable, called as smart/container components

vid-7:
    react 16.7.0 contradicts what we know about sfc vs class
    but now hooks are features that allow us to use state and other things without writing a class

vid-8:
    jsx
    javascriptXML --> allow to write xml like js code thus allows to have tag name,attributes,children
    now going to write a sfc that allows us to create UI without jsx
    hello.js under components dir
    React.createElement('div',null,React.createElement('h1',null,'hello Dhanush without jsx'));// here react.createelemt(elementtypetobecreated/tag,properties/attributeoftag,childrentag/innertext) note that react.creaetelement accepts any no of children tag
    here the second args ie null is nothing but an object with key value pair lik {id:'hello div id'}
    ie each time whenever we use jsx expression for return an implicit call is made using react.createelement() which returns an react element 
    in jsx some changes in the attributes is odne like
      class -> className
      for ->htmlFor
      onclick -> onClick
      tabindex-> tabIndex etc...

vid-9:
    props   
    allows the component to be dynamic and serves like optional input/args to component
    assume we have to pass name from App to Namegreet component which greets the entered name
    here the name="" is the thing seen to be passed by App to the component Namegreet thus inside nameGreet it must be accessed by this.props.name where this point to namegreet and props.name meant as this sent by APP which is name  
    assume now we don't know what are the things passed as props then we can use the children props concept ie the value inside the opening and closing tag of the component
    usually in react js we can return only one statement .. so to return multiple statement we've to wrap them inside a div tag
    props are immutable by default..ie their value can't be changed

vid-10:
    state & props
    we can use the state to influence what to be rendered if we opt out props
    props vs state:
        props get passed to component, these are usually termed to be used as functional parameters,props are immutable(can't be chnaged by child), accessed using props(in sfc) and this.props(in class component),
        state is managed within and by a component,these are variables inside the fn body/class , state are mutable by the component it is own by..  accessed by UseState Hook(in sfc) and this.state(in class component)
    using state to be influence UI by class component
    create message.js under component and made the changes
    assume we create a button there which on click makes message to change as from "welcome visitor" to "thank you for subscribing"
    here we can't pass that message as props(immutable) thus toggle value based on button click won't be applicable
    so we gonna use the state here for achieveing this
    we wrote the event handler onclick to point a fn which inturn calls the setstate() to change the state.messagevalue and reflects it in virtual and realdom
    //always use setState() to changes the state of a component...direct change without the setState() will change vlue internally but not reflected in DOMS

vid-11:
    setstate()
    ES7 react snippet extension
    lets create counter component
    rconst is the shortcut keyword to generate class component constructor
    put increment,decrement button with appr.method calls to do the funcytionality via setstate()
    always use setstate() if you need to change the state 
    don't place the code which are dependent on state under state modifying setState() calls..better proceed with setState(obj,callback) where callback is the remaining things to be done using modified state values...this avoids async difficulties
    imp.point:
        always make use of setstate and never modify the state directly
        code has to be execute after the state has been updated?
            then place that code in callback fn which is second args to setState()
        when you have to update state based on previous state value,pass in a function as argument(prevstate,props) instead of regular object to setState().


vid -12:
    destructuring state and props.
    destructuring is an ES6 feature that enable you to take out specific value from arrays/obj.properties into individual variables/elements
    thus it increases code readability.
    for eg in our case.. go to namegreet.js where we opt to use props.name,props.children, props.relation in sfc we could do it as ..see in the file.
    now we going to opt that for class component in same namegreet.js

VID-13:
    event handling
    assuming click event to understand the event handling 
     lets create a functional component as functionclick.js
    note always eventhandler=value .. the value must be of function/functionreferencor not as functioncall.
    like onClick={handle} .. not as onClick={handle()}
    for the same event handling in class component..see class-click.js
    rce-shortcut of es7 to create class component

vid-14:
    binding event handlers--(usually event handlers tend to odify state of class using this.setState() whenever an event occurs)
    there handling would be difficult as the 'this' context binding is hard to understand and bind.
    binding of the event handlers is just due to the difficulty of 'this' not because of any react practice
    we aim to change message on the click of a button where the message is a part of component's state
    created a file named eventbind.js as a class component
    methods:
       changes in render(): make binding in the eventhandler=value.bind(this)
        changes in render(): making use of arrow fn --> eventhandler={()=>handlerfn()}
        changes in constructor :making the binding in the constructor itself
        changes in class property  array fn assign to variable :making handler value fn itself as a variable assigned to an arrowfn that makes changes. class property as arrow fn

vid-15:
    methods as props
    child component wanted to communicate with parent component..then also we choose for props
    we pass a reference to a method as a prop to the child component
    create parentcomponent.js and childcomponent.js and do the necessary
    first normal child calls parent's greet()
    next child going to give a name that changes greet followed by name accordingly
    to pass method as props:
            define a method in parent component
            send that as props to child Component in format as handlername={parent-method-name}
            in the childcomponent, do the onclick=prop.handlername(args) ...

vid-16:
    conditional rendering
    types:
        if/else
        element variables
        ternary conditional operator
        short circuit operator
    new file->usergreeting.js


vid-17:
    list rendering
    we can use the map() to make use of iterating over array
    used the map() to call the adding of personcomponent which in turn call to add the h2 tags with the passed prop detais for displaying.. but when we see the console
    we get error but with correct rendering.. the error is nothing but "each child in the array or iterator must have an unique key prop"

vid-18:
    lists and keys
    the error in vid 17 could be considered as each item in the array(persons/personlist) must have an prop called 'key' and it must be unique
    so lets add it in the same files
    key props are not accessible in the child component..eg when we try to access it in personcomponent in case
    ie key props are reserved for the parent props alone
    key helps react to identify the things that are changed in the list implicitly
    assume  
            list :
                old list    new list
                    a           a
                    b           b
                                c 
        then react compares old tree dom with new tree dom side by side and finds out element c is missing then it merges it out and forms the olddom tree with a newly added element
        the issue comes when the list is like
                old list    new list
                    a           c
                    b           a
                                b
    here it finds out the first element mismatch and second element mistmatch..assume whole tree is new and starts to create everything from scratch for the new dom
    but simply it could keep a,b alone and fix the new element c and order of them..this could be achieved without hassle if the key prop is used

vid-19:
    index as key anti-pattern
    assume there is a list to be rendered from array(simple one) which may not have id/any unique parameter to serve as key prop..then what should be done on that case
    we could use the index of the element as the key prop
    but using index as key prop might also cause serious issues in terms of ui
    find attached link in video for reference
    where we have 4 buttons..add new to start,addnew to end, sort by earliest,sort by latest
    we have items with.. index, id, item description,created time
    adding to end of list was no problem..but but but when we try to add value to start then it's index should be zero and other items indexes must be modified accordingly but current item id must be increment
    the issue comes when index,id worked properly,..but the content of each items weren't shifted accordingly
    so see the video for more clarity..
    only use the index as keyonly  when it satisifes all 3 below:
            when list don't have unique id
            static list... not on crud based operations to be performed on list that changes ui
            list that never be sorted/filtered

vid-20:
    styling for react component-basics
       1 css --> made use of the mystyle.js and stylesheet.js
       2 inlne styling --> made use of inline.js
       3 css modules --> available with react scripts version 2(create-react-app)
       4 css in Js libraries-style component(refer somewhere else)
       now created stylesheet.js  and mystyle.css and inline.js
       for css modules based styling:
                    we must create the file with name format suffixed with module.css,
                    like within src we gonna create 2 stylesheets like appStyles.css and appStyles.module.css and included them into appcomponent
                    as the appStyles.css is applied to appcomponent via import..then it is applicable to child components of app component
                    ie you can copy the <h1 className='error'>error by cssstylesheet - appStyles.css</h1> and put it inside inline.js.. it would work and give inline in red color as mentioned
                    but appStyles.module.css is not applicable to the child components of the app component as it was imported there alone

vid-21:
        basic form handling in react
        capture input for various tag and have data available on for submission
        in html..elements are resposnible on their own for the form input handling..but what we want is the react to handle them.
        elements whose values are controlled by react is called controlled components
        form.js

vid-22:
    Component lifecycle methods
    stages in lifecycle... methods at these stages are called lifecycle methods which opts you to change the behaviour or UI if needed
    these lifecycle hooks/methods are mostly for the class component..where as for sfc there is useeffect hook similar to these lifecycle hook somewhat

    LIFECYCLE METHODS IN CLASS COMPONENT:
        TYPES:
            1 Mounting ->called .. when an instance of component is being created and inserted into the DOM
            2 Updating ->called .. when a component is being re-rendered as a result of changes made to either props or states
            3 Unmounting -> called .. when a component is being removed from DOM
            4 Error handling -> called ..when there is an error during rendering, in a lifecyle method or in constructor of any child component

        mounting has methods like
            constructor, static getDerviedStateFromProps, render , componentDidMount
        
        updating phase has methods like
            static getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, componentDidUpdate

        unmounting phase has methods like
            componentWillUnmount
        
        error handling phase has methods like   
            static getDerivedStateFromError and componentDidCatch

vid-23:
    Mounting lifecycle methods (flow)
           1)constructor :
                constructor(props)
                    usage:
                        it is a special function that will get called whenever a new component is created
                        it can be used for initialzing the state,binding the event handlers
                        we should not cause any sideeffect like making HTTP/AJAX requests here
                        while using constructor the super(props) must be called  and it is the only place where direct changing of state variables allowed without using the setState()

            2)static getDerivedStateFromProps(props,state): 
                    it is a static methods
                    classified as rarely used lifecycle method
                    usage:
                        when the state of our component depends on the changes made in props over time.. similar to controlled component but not restricted to it,
                        then in those cases we can use this to set the state of the component..as this is a static method.. 'this' keyword and this.setState can't be used here
                        so there we have to return a object that represents the new state of the component
                         we should not cause any sideeffect like making HTTP/AJAX requests here 

            3)render():
                it is required/must function in the class component
                it may/not read and use the props&state and returns the JSX/reactelement
                it is a pure function..it ensures to act same and produce UI for given state/props
                we should not change state here and we shouldn't interact with DOM and we shouldn't make ajax calls
                since the parent render() has the children component as the returning jsx..thus the children component lifecylce methods are also executed.

            4)componentDidMount(): 
                this will be called only once in the whole lifecycle of the considered component
                it is invoked immediately after the component and all of its child components are rendered to the DOM
                here we can cause/do the side effects like interacting with the DOM or calling AJAX/HTTP requests to load data

    now let's code:
        new file->lifecycleA.js and lifecycleB.js
    here we could see after A's render..child B's render happens..thenafter only all the componentdidmount happens

vid-24:
    Updating phase lifecycle methods
        1) static getDerivedStateFromProps(props,state):RARE
                static method that has to return either updated state as object or null
                it is called everytime whenever  a component is re-rendered
                sets the state
                must not cause any side effects
        
        2) shouldComponentUpdate(nextProps,nextState):RARE
                it recieves the updated props and state
                it decides whether the component has to re-render or not
                by default, all the class components re-render whenever the props/state they recieve is changed
                compare old and new state,prop value and return bool to determine whether react should update or not
                must not cause any side-effects
                must notuse setState()

        3)render():
                it is required/must function in the class component
                it may/not read and use the props&state and returns the JSX/reactelement
                it is a pure function..it ensures to act same and produce UI for given state/props
                we should not change state here and we shouldn't interact with DOM and we shouldn't make ajax calls
                since the parent render() has the children component as the returning jsx..thus the children component lifecylce methods are also executed.

        4)getSnapshotBeforeUpdate(prevProps,PrevState):RARE
                it is called right before the changes in the virtual dom to be reflected in the real dom
                used to capture some informations from the dom
                for eg:
                    read user scroll position and after the update it must relocate the screen to the previous screen coordinate by some calculation
                it will return either null or a value
                returned value will be passed as third arg to the componentDidUpdate()

        5)componentDidUpdate(prevProps,PrevState,snapshot):
                it is called after the render() in the re-render cycles
                which ensures that both component and it's child components would be updated.
                it is gauranteed it would be called once for each re-render cycle
                here we can perform the side effects...based on whether needed or not on th basis of snapshot& prevProps,PrevState

        using the same lifecycleA,lifecycleB files here.
    
    Unmounting phase lifecycle methods:
        1) componentWillUnmount():
                it is invoked when a component is unmounted and destroyed
                we can do cancelling any network request,removing event handlers,cancelling any subscriptions and also invalidating timers
                we can't use setState() here
    
    Error handling phase lifecycle methods:
        1) static getDerivedStateFromError(error):
        2) componentDidCatch(error,info):
        will refer in the error-boundary video, these methods are caled when there is a  error in rendering a lifecycle method in component or in constructor or in any child component


vid-25:
    Fragments
    this lets you to group the set of children without adding extra node to the dom
    fragmentdemo.js -- for basic eg
    multiple elements returned using render() the insetad of adding wrapper div we can opt React.Fragment
    create table.js and columns.js
    fragments can accpet the key value while rendering the list of items
    <> 
    </>
    empty opening and closing tags are also similar to react.fragment but we can't pass keywhile using this

vid-26:
    Pure components
    these all times we created class component by extending component class syntax
    ther is an another way to do class component creation via extemding purecomponent 
    shortcut to create purecomponent : rpce 
    file purecomp.js,regcomp.js,parentcomp.js
    component class vs pure component class ?
    we gonna do it with a demo by having a purecomponent,normal component and parent to both capable of changing its state
    //here the componentdidmount will execute after the first render then inside it..logic calls the setstate method for every 2 secons which causes the parent component rendering which in turn re-renders it's child 
    //regular component gets re-rendering along with the setinterval() but the purecomponent doesn't  

    it is because:
            a regular component does not implement the shouldComponentUpdate method. it always return true for updating by default
            a pure component implement shouldComponentUpdate with a shallow props and state comparison

    shallow comparison(SC):
            for primitive types like numbers,string etc
                a (SC) b returns true if a and b have same value and are of the same type
            for complex type like arrays,objects etc..
                a (SC) b returns true if a and b reference the exact same object 
                eg:
                    var a=[1,2]
                    var b=[1,2]
                    var c = a 
                    //here SC is nothing but ===
                    a === b --> returns false
                    a === c --> returns true   
                    b === c --> returns false
                    because as c is formed by a it is refers to the same object.it also stands same for objects
            
        a pure component implements shouldComponentUpdate with a shallow prop and state comparison

 does       sc of prevState with currentState    
 does       sc of prevProps with currentProps

if found changes in it then only re-render the component
note: never mutate the state.. always return a new object that reflects the new state while using pure component

vid 27 - memo:
    wkt purecomponents are for class components but to achieve the same with the functional components we gonna use React.memo
   parentcomp.js is also used & new file : Memocomp.js
   to make a component to behave as memo 
   use export default React.memo(our-componentname)

vid 28 - Refs:
    REFS ARE FOR CLASS COMPONENTS AND CANNOT BE ATTACHED FOR FUNCTIONAL COMPONENT AS IN UPCOMING VID 29
    refs / references makes it possible to access the DOM elements directly into the react
    we gonna like focusing a text input  field as usecase here...
    new file: refsdemo.js
    to use refs:
            steps:
                1) create a ref inside constructor by react.createRef()
                2) attach ref to needed dom element and it is done by using reserved ref attribute
                3)calling this.ourrefname.current.focus() -- for this usecase

    we gonna use the ref for the another usecase of fetching the input
    in the same file we gonna make changes

    we can also createrefs using a method called callback ref creation
    (bit older approach)
    steps:
            1) createref  and assign the value of property as null
            2) create a method that assignes the DOM element to the ref we created on step 1
            3)assign ref={ourrefsettermethod} in the dom element here the DOM element is implicitly passed as the element to setcbref
            note: REACT WILL CALL THE REF TO THE CALLBACK WITH DOM ELEMENT WHEN THE COMPONENTDIDMOUNTS AND CALLBACK THE REF WITH VALUE AS NULL WHEN COMPONENTUNMOUNTS
            4)add the focus to ref for this usecase

vid 29 - ref with class components:
        it is also possible to add ref to the whole class component itself
        new file:input.js & parentcomponent->focusinput.js
         assume here when btn is clicked here then the child component input.js will have to call focusinputfield() which inturn makes focus on the input field 
        we have created the ref in parent class and assigned the ref to the child class thus now we can access the child methods & properties via the ref name
        we have a button which when clicked calls the method clickhandle where we gonna access the child method focusinputfield() using componentref we created, which inturn calls the  focus statement

VID 30 - forwarding refs:
    ref forwarding is a technique to automatically pass a ref throught a component to one of its children
    newfile : FRinput.js(SFC TYPE),FRparentinput.js(CC TYPE)
    here when we click the button on parent comp then the input field on child component must recieve focus
    lets see how to do it now using ref forwarding
    step:
        1 create a ref in parent component
        2 attach ref to child component using ref attribute
        3 fowarding the ref to the inputfield in the child component using forwardRef() from react library--> rewrite the sfc as arrow fn and react.forwardRef assignment where the fowrward ref takes a arg which is nothing but our new sfc arrow fn
        wkt  sfc recieves props as its parameter but when the sfc is passed as arg to an forward ref then the same sfc recieves the ref as second parameter
        4 add handler fn for button click to call focus

vid 31 - portals:
    react portals provides a way to render children into a DOM node that exists outside the DOM hierarchy of the parent component 
    ie so far we had one dom element ie a div with id="root" in index.html were we've been mounting app.js which inturn is our whole react app
    ie it is also seen in index.js where we wrote reactdom.render(<app/>,document.getElementbyid("root"))
    here the protals allows you to create the react sub-app// our desired code to be rendered not under the div with id root this is called breaking parent hierarchy

    lets see with example
    lets add a dom node/element that falls outside  the root element
    in public/index.html .. we gonna add a div with id="portal-root"
    now  create  a new component: portaldemo.js
    in portal demo.js,
            we gonna return the reactdom.createportal() where it takes two params, jsx/components to be rendered and dom node where we need this app to be mount
    now when you inspect and see the hirarchy is not under root but under the portal-root div ... ie broke the app hiearachy that portals are aimed for

   why do we need portals:
     one case is having to deal with parent component css  when child component is a modal,popup, tooltip etc..
      to understand it please visit @ https://codesandbox.io/s/00254q4n6p
       
    
    event bubbling in portals: eventhough the child can be anywhere in the dom tree..ie including breaking app hiearchy .. but when event happens or its functionality is similar to a normal child
    ie event fired from inside a portal will propagate to ancestors in the contaiing react tree even if those elements are not ancestors in the dom tree...
    visit @https://codepen.io/gaearon/pen/jGBWpE

vid 32 - Error boundary:
    error handling phase  in lifecycle methods as static getderivedstatefromerror(error) and componentDidCatch(error,info)
    basically the react unmounts the whole app tree when we come across an runtime error
    but think if we could catch the error and display it somewhere without affecting UI and app tree components --> Fallback UI
    a class component which implements either one or both of the above mentioned methods will be treated as a error boundary
    static method getDerivedStateFromError is used to render a fallback UI after an error is thrown
    componentDidCatch is used to log the error informations

    example: newfile Hero.js
    to make some error to understand this we gonna say if the heroname is villain then we should throw the error
    initially when we don't write the componentDidCatch and getDerivedStateFromError then whole app crashes but what we need to do is to fallback/moveback the UI that causes the error and others are still rendered
    to do that we gonna create a new file called errorboundary.js
    
    errorboundary catch errors during rendering and also the during the constructor of the whole component tree below them
    they don't catch errors inside the event handlers so to catch error inside event handlers better opt for the try,catch statements

vid 33 - Higher order component part 1
    why higher order component is needed?
    new file clickcounter.js
    assume after written no of times button clicked fn in it .. we need to also implement that a heading which shows how many times we hovered over it
    so newfile hoverCounter.js
    now after implementing this also..say client needs a change
    an input element that counts the number of key presses newfile:keycounter.js
    but see here are actually duplicated the saem increment count function..that makes redundant code
    we should have opted for the reusable code usage rather than duplicating and pasting the same increment fn everytime
    so to make code reusable..we might think to lift the state up to a common parent component and pass down the handler as props
    it would work for this scenario as we could think these are to be made under parent-child component relationship
    assume if there are multi-level among these component then sending state(COUNT),handler as props and maintaining them would be too tedious
    so inthose scenario, to ahre a common funcytionality between components without lifting state up we could opt for the "higher-order components"

vid 34 - higher order components(HOC) part 2
    what is HOC :  it is a patern where a function takes a component as an argument and returns a new component
    eg : const newcomp = HigherOrderComponent(oldcomp)
    typically an hoc adds data or functionality to the original component and returns them as new component
    the new component can be  caled as 'enhancedcomponent'
    like const ironman = withsuit(tonystark)
    lets try to implement a basic hoc and then try to build another hoc for the key,click,hover counter example
    basic hoc: withcounter.js (hoc filenaming convention camelcase)
    note whenever the enhanced component ie hoc added component is seen...we could state that those components has the props which could mimick the behaviours as state for hoc alone...ie newcomponent from hoc has the props as mutable without having extra local state var to prop assignment.. note the original count memory/value won't be modified eventhough props act as mutable here
    ie HOC individually returns the props as their shadow state to the key,hover,click components here and make sure that one's change of count doesn't interrupt the others 
    naming convention changes are made in files

vid 35 - higher order components part 3
    passing down the props: assume we passed a prop named message from app to clickcounter and try to render it in clickcounter but it won't be displayed
    this is because when props are mentioned for the clickcounter .. then those props are sent to the hoc not the clickcounter due to export statement we mentioned in clickcounter hoc(clickcounter)
    so now also to pass down that props from app to hoc then hoc to clickcounter we have to write that in hoc
    <wrappedcomponent 
        ourinitialpropsstatements={..blah,blah,blah..}
        {...this.props} //-->this is spreading remaining props
    </wrappedcomponent>

    passing paramters to hoc functions ie for incrementcount()

    say in with counter make changes in
        class withCounter =(wrappedcomponent,incr.number)
        {
            ....    
            ....
            ....
            incrementcount=(incr.number)
            {
                    logic: .. ,., + incr.number
            }
        }

    then in clickcounter export default withCounter(clickcounter,3)
            keyounter export default withCounter(keycounter,5) 
like that we can do it in hoc....


vid 36 - render prop pattern:
    this is also a pattern to share data between components
    newfile : clickcounter2.js,hoverCounter2.js
    similar to without hoc we are here duplicating the code..so to remove redundancy we go for Renderprops pattern here

vid 37 - render props part 2:
    render props:
   newfile: User.js
   by seeing the user.js we can understand that it is possible to have a prop named render which will have a function and can cantol the UI based on the fn body
   render props : technique for sharing code between react components using a prop whose value is a function
   so now we gonna do that for the  counter example
   newfile county.js

(if doubt arises better proceed to watch video of HOC and render prop)

vid 38 - context part 1:
    react context.
        assume we have a structure like below.. where app has a state var called username.. which is need to be rendered on components like A,D,F for our usecase

                app 
        ---------|---------
        A        B        C
                 |        |
                 D        E
                          |
                          F 
                
    here see sending the username to components like
        A = app -->username as prop to A
        D = app -->username as prop to B --> then B -->username as prop to D
        F = app -->username as prop to C --> then C -->username as prop to E --> then  E -->username as prop to F

here eventhoughthe components like B,C,E doesn't need the username we have to make it to passthrough them inorder to get them to their descendant components... it could be worse if the level of intermediatory components exceeding say 5 levels
so to send the data as prop directly to the required component without infecting the other components then we could use 'CONTEXT"

CONTEXT PROVIDES A WAY TO PASS DATA THROUGH THE COMPONENT TREE WITHOUT HAVING TO PASS PROPS DOWN MANUALLY AT EVERY LEVEL


vid 39 - context part 2:
    now for the particular use case we could take app(username)->c->e->f(needed prop-username from app)
    so now make files like compc,compe,compf,usercontext.js and do the nesting
    3 steps for using context:
            1) create the context --> usercontext.js
            2) provide a context value -> say placed context in a component then it's descendants alone can consume the context
            3)consume context value in necessary components/area --> we needed it in compf so we wrapped our message 


vid 40 - context part 3:
    we can set a default value to our context by sending that as a argument to the react.createcontext();
    if the default value is set in set one and the contextprovider is not done/wrote but contextconsumer is used then the value to be rendered will be the default value that we set in step 1
    contextType property -- > implicit access of the contextprovider value/ default context value
    if it is so easy then why can't we simply use the contextType rather than contextconsumer
            because it has some limitations like    
                  1) contextType only works with class components
                  2) we can subscribe only to a single context using the contextType

    refer the multiple context consuming in the video.

vid 41 - react and HTTP part 1:
    react is just UI based library which is no way concerned about the HTTP comms with the server
    then how do we make ajax/HTTP request/api calls in react?
    react doesn't have a way to fetch / send data/request to the server.. it doesn't even need to know that there exists a server to be communicated
    usually react assumes the data to be rendered is based upon the props and state not the server side value .. it is react's assumption
    thus to handle such server based request/response we would need a HTTP library which could be anything like axios,fetch and other libraries too... we gonna use axios for understanding
    so lets add axios package and does the stuff -- npm install axios

vid 42 - react and HTTP part 2 - get request:
    now lets see how to fetch data from api using axios and display it
    for api endpoint...we gonna use JSON placeholder api
    new file : postlist.js
    the control flow is like   initially constructor called where posts[] is empty, then after that render() is called where lists of post title is displayed but they don't have list of 100 post
    then goes for componentDidMount where api fetch is done by axios and state is updated ie posts[] are populated thus re-rendering of component happens as the state changed

vid 43 - react and HTTP part 3 - post request:
    lets try to post data to an api from our react app
    lets try to have 3 input fields and on submit btn click then http post has to be made to the api
    new file : postform.js

vid 44 - react hooks intro
    what are hooks?
        it allows to use react features without writing a class... from version 16.8 react introduced hooks
        eg : to use state we had to write a class component.. but now by using hooks u can use state by hooks in functional component
        hooks doesn't work inside classes
    why hooks?
      reason set 1:
        to work with classes.. we needed to understand working of 'this' keyword in js.. which is tedious in react class comps
        we also needed to remember binding event handlers in class components
        classes don't minify very well and make hot reloading very unreliable
       reason set 2:
        there is no particular way to reuse stateful component logic between components
        the reusablecode could be achieved using HOC and render-props but that involves wrapping and restructuring of code..which would be an extra effort
        this also makes code harder to follow
        hooks- makes a better way to share stateful logic without changing the component hierarchy
       reason set 3:
         while creating components for complex scenarios such as fetching and subscribing to events we find that related code are not organized in one place
         but seems scattered among different lifecycle methods
         eg: data fetching could be in componentDidMount and componentDidUpdate
         eg: event listeners in componentDidMount and componentWillUnmount
         see here both data fetching and event listeners are in componentDidMount
         due to stateful logic sometimes its harder to break/segregate them into samller ones
         these could be solved by hooks which allows you to break the needed ones into smaller functions rather than typical lifecycle bsaed method rules

        HOOKS PROVIDES A MORE DIRECT API TO REACT CONCEPTS THAT WE ALREADY KNOW SUCH AS
            PROPS,STATE,CONTEXT,REFS AND SOME LIFECYCLE

vid 45 - Usestate hook:
    usestate hook allows us to use the state in functional components
    we gonna consider a simple counter example for this hook now
    newfile : hookcounter.js
    code flow will be like  
            import usestate
            then call usestate with default value that makes the component to mount and then note that default value wont be used on re-renders
            when btn is clicked the state count would be updated by incrementcount which takes parameter ie nothing but logic to be done ie oldcount+1 
            which makes the updation in count and thereby leading to re-render and UI change
    
!!!!!Rules of hooks!!!!!!:
      only call hooks at top level
      don't call hooks inside loops,coditions, or nested functions
      only call hooks from react functions ie from react functional components not just plain js functions

vid 46 - useState with previous state:
    here we are going to implement counter with increment,decrement and reset the count..which makes the prevstate count as a dependency
    newfile :hookcounter2.js
    here the count+1,count-1 as logic passed as params to setCount which is similar to setState is very unsafe way of state updation..lets c y
     assume now we add another button that increments that count value by 5
     here you could observe that the value gets incremented by 1 rather than 5 each times and gives out irregular outcome
     it is becuase the setCount is still using the stale value of the loop 's 1st iteration
     so we have to use the second form of the setCount function that is accepting the function as parameter which has access not only to the stale value but also to the previous state property count
     so replace it right there, so it is also applicable to  increment,decrement at somepoint so ..replace it there as well 
  ~~~~~~~~  note ie whenever you need to update a prevState depended newState value ... then better pass a fn to setState() that has prevstate property like prevcount to setCount() in our case ~~~~~~~~~~

vid 47 - useState with objects:
    here we are going to make use of an object as the state property variable
    new file:hookcounter3.js 
    there initially we could see that when we type in firstname ..lastname is removed from state and viceversa
~~~~~~~~ note: this is because "usestate's setter function doesn't automatically merge and update the object"
    so that we have to do the merge and update manually using this spread operator


vid 48 - useState with arrays:
    here we're going to make use of the array to be a state property variable -- to be precise state = == array of objects here
    newfile :hookcounter4.js

UseState HOOK Summary:
        it lets you to add state to functional components
        in class component state is always and object but in functional component with useState .. the state can be number,array,object,array of objects etc...
        useState() hook returns 2 elements one is current state property value with default value assigned and another one is a state setter function
        in case, the new state value depends on prevstate value .. then we have to pass a function as argument to the setterfn with access to prevstate
        if the state property variable is object,array,array of object  make sure to spread them(state property value) in setterfn as the usestate setter method by default doesn't handle the merge and updation of all state property value

vid 49 - useEffect Hook:
       while using the class components we would have made use of the lifecycle methods such as componentdidmount,componentDidUpdate for the data fetching and componentDidMount,componentWillUnmount for timer related sideeffects etc.. 
       but in class component by doing such things we get to face the issues such as the code redundancy,unrelated codes are in same lifecycle methods and yet related codes but they are scattered among different lifecycle methods
       useEffect is addressing the solution for above issues and it allows us to perform the side effects in functional components 
       it is known to be a close replacement for the componentDidMount,componentDidUpdate,componentWillUnmount

vid 50 - useeffect after render:
        we are going to mimick the usage of componentDidMount,componentDidUpdate using the useEffect hook in the functional components
        here we have the usecase as the component that updates the title of the document with the counter value... whenever the increment btn is clicked the title gets updated
        lets write it with functional component with useeffect
        newfile : hookue1.js
        //useeffect is also a function hook which could be called where the parameters are nothing  but a function which we need to be called after every render cycle
        //here in our usecase whenever we click the button we need to update the document title as well.. so after each state update,the render is called.. then after that we need to manually add the changed count item in the title thus we gonna make use of componentdidupdate in class component but here we gonna make use of useeffect hook
        //where the params is the empty arrow function with our logic
        working flow of useEffect : when we specify useEffect,we are asking reeact to execute the function that we passed as params... everytime when the component renders... ie it also runs during the first render and then further update rendering also
        we could customise what should be in initial render and followed by updates with different logic can be achieved using the conditional rendering
        both usestate and useeffect are inside the functional components thus useeffect can use the state by usestate and if anyother props available without any extra codes

vid 51 - conditionally run useeffect:
        sometimes making call to unneeded logic both on initial render and subsequent update render will cause performance issues
        so we need to find a way to conditionally render/use the useeffect hook inside a functional component
        for here the usecase we gonna consider ... we have input that accepts a text to state.name.  
        but when we do like that assume input is dhanu and we have a log statement says didupdate called in componentDidUpdate.. there we could find that the whenever the input changes but button not clicked..we could see that the same title was assigned to document title each time.. thus it could be avoided by conditionally seeking whether the previous count === now count then we could skip that assignment likewise
        new file : Hookue2.js
        //conditionally using the effect hook
        //we could achieve it by passing a second args to the useeffect which is of type array..where in which we could mention either the state or the props that we need to keep an eye for change... if those changes then only the effect executes
        //here now by default react with useeffect will implicitly check for change in count.. if changes are seen then it would execute else it would be not executed..  thus change in the state->name happens but it isn't provided in the useeffect second param the useffect() logic won't execute


vid 52 - Run effects only once:
    lets see how to run useeffect only once or let's see how to mimic the componentdidmount using useeffect
     assume for this usecase..we have a component that makes notes of the mouseposition initially
     ie in class component we would listen for mousemove event and log the mouse coordinates in the UI by storing those coordinates in the state via the componentDidMount..lets see how to mimic it using useEffect
     note we have to write the logic of setting up the mouse event listener in componentDidMount..not the tracking logic okay..so concentrate to make the same using useeffect
      newfile : Hookue3.js
      // here  [] specified on second param states that this useeffect down't depend on any state or props..thus we don't need this logic to be executed more than once(ie only during initial render not on updates) explicitly

vid 53 - useEffect with cleanup:
    lets see how to mimic the componentWillUnmount functionality with the useEffect hook
    lets understand where we could possible use the componentWillUnmount..
    for our understanding lets consider that we create container component for the hookue3.js/ mousecoordinate example with a button that will toggle the container's visibility
    newfile:Mousecontainer.js, hookue4.js
    eventough the display is set to false... in console we could observe the mouse coordinate change event console log..with a warning that shows that the component(hookue4) was unmounted but the event listeners/unsync task in that component was not cleaned up/relieved from the DOM ( which in class component done via componentWillUnmount)
    ie stating can't perform update in unmounter component..will is nothing but a memory leak
    this could be resolved using useEffectwith cleanup functionality
    ie fn passed as first param to the useeffect() will return another fn implicitly which could be used to mimic the componentWillUnmount .. so explicitly return an function will removing eventlistener logic

vid 54 - useeffect with incorrect dependency:
    lets see the common mistakes that been done by the person who learnt class components then functional with hooks especially useeffect here
    consider we have a counter that automatically updates value everysecond usng setInterval logic
    newfile : intervalhookcounter.js
    //this one only executed only once making count=1 and stopped working
    //the problem is "when we try to use the dependency array(2nd param to useeffect) to determine when to render/re-render we will run into implementation problems"
    //rather than try to use the [] to mimic componentdidmount/willunmount we must use that to let reat know what state var it should monitor to execute the useeffect logic
    // here react thinks that the change of count to 1 has happened but while trying to mimic componentdidmount for timer,,we forgot to add re-render condition then behaves like componentwillunmount ie count incrementing which also needs to be done using the useeffect hook(only one call to setinterval will be sent)
    //dependency list is added to make it work for all re-rendering,componentwillmount,componentupdate,componentwillunmount
    //another way to make it work without dependency list is to modify the tick function .. here the setcount inside tick() takes care of count's value usimg pevcount we could remove the count from dependency list .. but still it will behave as componentDidmount,componentwillunmount,componentDidupdate
    note:sometimes you might want to call a function within useeffect, it is preferred to also define the functionbody/logic within the useeffect to avoid the reference error that may happens if the params to the function is not accessible to the useffect incase where th fnbody is defined outsde useeffect..note that prop could be a dependency and need to be mentioned in second param..ie dependency array to useeffect

    specifying multiple useffects():
    it is possible to include multiple useeffect() calls within the same component, refer the docs

vid 55 - fetching data using useffect part1:
    there would be a feature called "suspense" which would be responsible for data fetching
    we gonna  use useeffect for api fetch using axios
     newfile:datafetchue.js

vid 56 - fetching individual post by providing id in useeffect part 2:
    newfile:datafetchue2.js
    it is correct but for each change in input field we hit a get api fetch..which is not optimised..lets try to change it in upcoming session

vid 57 - fetching data using useffect part 3:
    we would create a button and write a handlerfn within which we hit the api call
    it is good but we need to achieve the same using effect hook
    we need to create a state variable whose value would be changed on the button click event
    newfile:datafetchue3.js

vid 58,59 - Usecontext hook part 1,2:
    normal explanation of context usage (same as vid 38,39,40)
    usually consuming multiple context means more nested provider and consumer context code is to be written thus to overcome it we gonna make use of usecontext hook

vid 60 - Usecontext hook part 3:
    newfile:compe1,compc1,compf1 
    the usage of Usecontext is similar to traditional context usage but a slight change
        1) create a context
        2) provide context at higher level/parentcomponent to make sure that their child can consume them 
        3) consuming value alone is chnaged using the usecontext hook

vid 61 - useReducer what and why:
    usereducer is a hook for state management
    state management is also done by usestate thus usereducer act as the alternative to usestate
    usereducer is primitive hook when compared to usestate .. in fact usestate was built on the basis of usereducer
    when to use useReducer and when to use Usestate? we will know that after the exaample we learn..let's revisit this question later
    from the name of the state itself we get to know their purpose like 
            usestate-state management
            useffect - perform side effects
            usecontext - context api
            usereducer - reducers
    it is not necessary to know redux to understand the usereducer but knowing it will increase the understandability
    reducers:reducer is nothing but the manual fn logic that we give for reduce() in js...the reduce() will result a single output
    reduce() will take 2 paramters first arg is the user's fn logic and second args is nothing but a initial value that the function could make use of
    reduce(reducerfn,5)

    |||rly , 
                reduce in js                     ||||               useReducer Hook
            array.reduce(reducerfn,initialvalue)                useReducer(reducerfn,initialstate)
     singlevalue=reducerfn(accumulator,itemvalue)               newstate=reducerfn(currentState,action)  //action is nothing but a thing which determines the change from current state to new state
            reduce() returns a single value                     useReducer returns a pair of values [newstate,dispatch]  //dispatch method is basically used to specify the action

vid 62 - useReducer (simple state & action)
    for understanding we gonna create a counter example and try to understand concept
    newfile:counterur1.js
    1) import usereducer from react
    2)define initial state and reducerfn
    3) add event handler logic with call to dispatch(appr..action name ) like disptach('increment') which goes to reducer(state(ie count),increment) likewise execution

vid 63 - useReducer(complex state & action):
    here state and action are not simple number,string etc,... but they are going to be objects
    newfile:counterur2.js
    note: we can maintain both state as well as action as the objects..
    by maintaining action as object we can have additional data to the reducer function
    by maintaining state as object we can keep track of multiple state variables
    mainataining multiple state varaible as single object is best preferred for the case of a global state object
    but for local state/1 component needed state we have another way to maintain multiple state variables.. lets see how in next section -- > can be achived using multiple usereducer hooks

vid 64 - Multiple usereducer hooks:
    newfile:counterur3.js
    note: when dealing with multiple state variables that have the same state transitions/actions, it is good to use the multiple usereducers making call to same reducerfn but changes in statevarname,dispatchname should be maintained
    thus it allows to avoid the complexity of merging the state one/other incase of those two statevariables are coupled to be used as a single state object variable and also reduced duplicating code
    note : so far we have only seen usereducer for local state management that is at component level

vid 65 - usereducer with useContext:
    useReducer - local state management
    but at some point of time we might need to share the state of an component among other one .. ie working with global state
    we can manage global state by combining usereducer with usecontext hook
    assume an usecase scenario where we can three child components to app component where we need to implement a single counter and those counter value and method should be accessible by all three children say a,b,C
    there we could use the usereducer with usecontext
    we might use the method as prop to the parent comp but it is not applicable if the level of tree hierarchy is more..ie deeply nested children..there we have to go for usecontext with usereducer
    assume the same hierarchy in vid 38,39..but the differene is here the counter is implementted in app.js and needed to be accessible from a,d,f components
    newfile:componenta,b,c,d,e,f.js
    create a counter in app.js using reducer hook
    provide and consume counter context in needed descendants

vid 66 - fetching data using usereducer hook:
    newfile:fetchUR1.js
    here we aim to fetch data from endpoint ..we have loader if fetch successful show data else show error message
    here we gonna first make it traditional fetch using the usestate,useffect

vid 67 - fetching data using usereducer hook part 2:
   newfile:fetchUR2.js  .. lets see how to mimic the same using the usereducer hook for this particular usecase

vid 68 - useState vs useReducer:  
    scenario                    Usestate can be used                useReducer can be used
 type of state variable           number,string,boolean              object/array
 no of state transitions           one or two                        more than 3 inside a component
 related state transitions         then don't use                    use it
 business logic                    easy logic                        for complex business logic
 state                             local component state             global state mngt   

vid 69 - UseCallback hook:
    lets start what is performance optimization?
        assume the code logic in video for understanding  the performance optimization.
        here in video the code is like we have a parentcomponenter.js which in turn has a title component with logic of displaying the title and count component where we have prop of text="age" and count={age} and it will render the text and count prop through destructuring then we have a button to increase the age from parentcomponenter and then we again have a count component which in turn will renderout the props text=salary and count={salary} then after that we have a button to increment the salary from parentcomponenter 
        we have explicitly added the console.log statements in each button,count and title component to know about the performance optimization and its metrics
        you could observe that whenever the button is pressed instead that component alone re-rendering all the components gets re-rendered which inturn leads to heavy performance issues.
        it would be a tedious incase of more nested components.
        to improve performance, we have to restrict re-render to the components which only meant to be re-rendered and others untouched.
        eg:increment age is pressed then only the age component and button component related to the age must be re-rendered and all others must be left untouched
        to get this implemented we have to opt for the react.memo(needed components)..which makes the re-render only if there is a change in its state or its props..else no re-rendering
        but the issue that we observe is that when we click the increment age/salary both the button components gets render logs .. it is also a minor performance issue
        it is because each time whenever the parentcomp is re-rendered we get to see a new salaryincrement() also created but the fact is that it is different due to the reference equality of the parentcomponenter instance
        ie in sfs component.. the function inside the component defn is different from the function after the re-render..thus react.memo doesn't restrict the re-rendering as the prop incrementsalary is now a new different reference
        To fix this issue of re-rendering due to the reference equality of the parentcomponenter instance.. we opt for the use callback hooks
       newfiles are under /component/usecallback 
       
       what is callback hook:?
             Usecallback is a hook that will return a memoized version of the callback function that only changes if one of the dependencies has changed.
             in our usecase, here ther incrementsalary fn will be cached by react and be returned only if the salary is not incremented.if salary incremented,then a new version of incrementsalary() will be formed and returned
       why  we need usecallback hook:?
             it is useful when passing callbacks to optimised child components that rely on reference equality to prevent unnecessary renders.
       how to use callback hook:?
            import usecallback from  react
            write the usecallback function which accepts a callback function as a parameter and dependencies  array will be second parameter
        
        callback hook is use to achieve performance optimization
       
        why not we use the callback hook everysingle time?
        Answer:  https://kentcdodds.com/blog/usememo-and-usecallback

vid 70 - useMemo hooks:
      this is also a hook that is related to performance optimization
      newfile:countermemo.js  
      made 2 state variable and 2 function which inturn calls 2 countervariable setting functions inside them..which are to be triggered using btn onclick event handlers
      it works fine..but assue now we have to show the number is odd or even near the btn 1
      assume the iseven function in our case is now a very complex function that is not so good with performance optimization and requires considerable amount of time in real world.( like modifying array with 1000 items and their mapping and everything)
      so now manually we introduce some delay in the iseven function
      here the manually placed loop doesn't affect the output value but definitely the return time of the output would be increased.
      there you could experience a delay in the counter 1 button but also you could see that there is a delay in the counter 2 as well in terms of the UI updates.
      it is because whenever the state is changed there exists an re-render where the call to iseven function is hit in the jsx part of return() thus making it to slow the ui update in counter 2 as well
      so thus we need a way to tell react to not to use the iseven function/long time consuming function execution unnecessarily .. ie iseven must not be called whenever interaction happens in counter 2
      now we gonna usememo hook here
      usememo hook will only recompute the cached value when one of the dependencies has changed.which allows you to avoid expensive calculations on every render.
      it is similar to usecallback in working flow.
      steps:    
            import usememo hook
            it takes two arguments..one is the function whose return value needs to be cached which in our case is iseven() and other one is dependencies array
      thus after this we could experience delay in counterone iseven but the performance of the countertwo update is seamless because whenever the state of counter2 is updated..component re-renders but the counterone is not updated thus the cashed value of iseven is retained each time

      usememo and usecallback seems similar but the difference is :
                usecallback caches the whole function itself
                but the usememo caches the function's result only ,after function is invoked


vid 71 - Useref hook part 1:
        this hook makes possible to access the Dom nodes directly inside the functional components
        for understanding  ...we gonna take scenario of making focus to an inout field usecase
        newfile:reffocusinput.Js
        steps:
            import useref from react
            create a ref variable by calling useref and passing the initial value ie null
            then attach the ref to needed element ie input field here
            then in useeffect we gonna make the focus call for the element through ref.current.focus() property

vid 72 - Useref hook part 2:
    assume that there is a classtimer class component which gonna display value of timer in state  incremented each second and  we remove/stop the timer in componentwillunmount through a button click
    now think that we have to replicate the same using functional component
    newfile:reftimer.Js
    there you could see the error that interval variable is scoped inside the effect hook and can't be accessed inside the btn handler function.. there we could opt for the ref concept using useref
    note useref can also be used to store DOM node and also the mutable values(general const,variable etc..)
    again note that value stored in useref will persist throughout the re-renders and doesn't cause any re-render eventhough the stored value in useref is changed

    useref can also be used to create a general container to store generic mutable value similar to instance property in a class component
    this generic counter doesn't causes any re-render eventhough the stored value in it was changed and also remembers the value in container evenafter the re-render triggered by someother state var changes of that component
    still we need to see : useimperative handle,uselayouteffect and usedebug value hooks

vid 73 - custom hook prelude:
    so far we have discussed about 
        useState,
        useEffect,
        useContext,
        useReducer,
        UseCallback,
        useRef,
        useMemo
    these are the hooks which are provided by the react library.these are mere function which could be invoked by our component
    we can create our custom hooks by extracting the functional reusable logic.
    A custom hook is basically a javascript function whose name starts with 'use' keyword.
    A custom hook can also call other hooks if required.
    we opt the custom hook to share logic between components..thus serves as alternative to HOC and Renderprops

vid 74 - custom hook - useDocumenttitle Hook:
    we gonna create a counter and place the countervalue as document title without using custom hook and then achieve the same using custom hook
    newfile: Doctitle.Js
    now we want to update the title from another component
    newfile:Doctitle1.Js
    assume likewise 10 different component want to update the same document title then we would be repeating same logic in all component..which is massive code redundancy
    to avoid it we could build it as a hoc/renderprop and use it else...as we know hook now..we could create a custom hook with that logic and import it and use it wherever needed
    now newfile: /customhook/useDoctitle.js
    starting with 'use' makes the linters to understand these are hooks are follow the standard of the hook rules and conditions.
    the redundant code was nothing but the updation of doctitle in useeffect in previous file..make it as logic for our custom hook

    ALWAYS TRY TO REUSE THE LOGIC(EITHER BY HOC/RENDER-PROP/CUSTOM HOOKS)  RATHER THAN DUPLICATING THE LOGIC IN EACH COMPONENTS
    WHENEVER THERE IS A CHANGE IN STATE, RE-RENDER HAPPENS WHICH INITITALLY CALLSOUT THE FUNCTIONS WHICH ARE DEPENDENT ON THE STATEVARIABLE AND OBTAINS THE RESULT...THUS WHENEVER THE COUNT IS INCREMENTED AUTOMATICALLY THE USEDOCUMENTTITLE HOOK IS called AND INDISE THAT THE EFFECT HOOK CHECKS WHETHER THE COUNT IS CHANGED/NOT .. IF CHANGED THEN PERFORM THE LOGIC ELSE DO NOTHING

vid 75 - custom hook - usecounter Hook:
    here we're going to create a counter logic as a usecounter hook
    newfile: counterwithouthook.js,counterwithouthook1.js
    now to make the code reusable  we gonna make use of the custom hook ..
    newfile: /component/customhooks/usecounter.js

vid 76 - custom hook - useinput Hook:
    custom hook created for input elements
    we gonna have a simple form where user gonna enter their first and last name
    newfile:userform.js
    what our custom hook is goint to do is to encapsulate the behaviour of the input field's onchange event and value={statevar} mapping
    newfile: /component/customhooks/useinput.js
``!!!!!!!! mine is not working yet to debug why !!!!!!!!!!``
 